{
  "hash": "0c2a089dbad54e75b9e8f2212096aed5",
  "result": {
    "markdown": "---\ntitle: \"False-positive risk (power loss) when adding a futility interim analysis to a clinical trial\"\nauthor: \"Kaspar Rufibach, 6th March 2024\"\nexecute:\n  freeze: auto  # re-render only when source changes\noutput: \n  rmarkdown::html_document:\n    highlight: pygments\n    number_sections: no\n    self_contained: yes\n    toc: yes\n    toc_depth: 3\n    toc_float: yes\n    code_download: true\n---\n\n::: {.cell}\n\n:::\n\n\n# Purpose of this document\n\nThis R markdown file accompanies this [linkedin post](https://www.linkedin.com/feed/update/urn:li:activity:7171170319980871680/), provides the code to reproduce computations, and much more. I also talked about this topic at the first 2024 [effective statistician conference](https://theeffectivestatistician.com/welcome-to-the-effective-statistician-conference-2024/), find my slides [here](https://numbersman77.github.io/kasparrufibach/files/talks/20240215_Rufibach_Futility.pdf)\n\n# Acknowldegments\n\nI talk(ed) a lot about this broad topic with my Roche colleagues Marcel Wolbers, Jenny Devenport, Gian Thanei, Jianmei Wang, Gaelle Klingelschmitt, Uli Burger, and many others.\n\n# Setup and definition of functions\n\nWe define a few hand-knitted functions to simulate clinical trials. I am sure there would be off-the-shelf methods for this, but I simply reuse what I have already.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(survival)\nlibrary(rpact)\nlibrary(reporttools)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLade n√∂tiges Paket: xtable\n```\n:::\n\n```{.r .cell-code}\n# Quantile function for a Weibull distribution with a cure proportion\nqWeibullCure <- function(p, p0, shape = 1, scale){\n  res <- rep(NA, length(p))\n  ind1 <- (p <= p0)\n  ind2 <- (p > p0)\n  res[ind1] <- Inf\n  res[ind2] <- qweibull(1 - (p[ind2] - p0) / (1 - p0), shape = shape, scale = scale)\n  return(res)  \n}\n\n# censored time-to-event data with censoring after pre-specified number of events\nrWeibull1arm <- function(shape = 1, scale, cure = 0, recruit, dropout = 0, start.accrual = 0, cutoff, seed = NA){\n  \n  # shape             Weibull shape parameter. \n  # scale:            Weibull scale parameter\n  # cure:             Proportion of patients assumed to be cured, i.e. with an event at +infty.\n  # recruit:          Recruitment.\n  # dropout:          Drop-out rate, on same time scale as med.\n  # start.accrual:    Time unit where accrual should start. Might be useful when simulating multi-stage trials.\n  # cutoff:           Cutoff, #events the final censored data should have (can be a vector of multiple cutoffs).\n  # seed:             If different from NA, seed used to generate random numbers.\n  #\n  # Kaspar Rufibach, June 2014\n  \n  if (is.na(seed) == FALSE){set.seed(seed)}\n  \n  n <- sum(recruit)\n  \n  # generate arrival times\n  arrive <- rep(1:length(recruit), times = recruit)\n  arrivetime <- NULL\n  for (i in 1:n){arrivetime[i] <- runif(1, min = arrive[i] - 1, max = arrive[i])}\n  arrivetime <- start.accrual + sort(arrivetime)\n  \n  # generate event times: Exp(lambda) = Weibull(shape = 1, scale = 1 / lambda)\n  eventtime <- qWeibullCure(runif(n), p0 = cure, shape = shape, scale = scale)\n  \n  # Apply drop-out. Do this before applying the cutoff below, in order to correctly count necessary #events.\n  dropouttime <- rep(Inf, n)\n  if (dropout > 0){dropouttime <- rexp(n, rate = dropout)}\n  event.dropout <- ifelse(eventtime > dropouttime, 0, 1)\n  time.dropout <- ifelse(event.dropout == 1, eventtime, dropouttime)   \n  \n  # observed times, taking into account staggered entry\n  tottime <- arrivetime + eventtime\n  \n  # find cutoff based on number of targeted events\n  # only look among patients that are not considered dropped-out\n  time <- data.frame(matrix(NA, ncol = length(cutoff), nrow = n))\n  event <- time\n  cutoff.time <- rep(NA, length(cutoff))\n  \n  for (j in 1:length(cutoff)){\n    cutoff.time[j] <- sort(tottime[event.dropout == 1])[cutoff[j]]\n    \n    # apply administrative censoring at cutoff\n    event[event.dropout == 1, j] <- ifelse(tottime[event.dropout == 1] > cutoff.time[j], 0, 1)\n    event[event.dropout == 0, j] <- 0\n    \n    # define time to event, taking into account both types of censoring\n    time[event.dropout == 1, j] <- ifelse(event[, j] == 1, eventtime, cutoff.time[j] - arrivetime)[event.dropout == 1]    # same as: pmin(tottime, cutoff.time) - arrive\n    time[event.dropout == 0, j] <- pmin(cutoff.time[j] - arrivetime, time.dropout)[event.dropout == 0]\n    \n    # remove times for patients arriving after the cutoff\n    rem <- (arrivetime > cutoff.time[j])\n    if (TRUE %in% rem){time[rem, j] <- NA}\n  }\n  \n  # generate output\n  tab <- data.frame(cbind(1:n, arrivetime, eventtime, tottime, dropouttime, time, event))\n  colnames(tab) <- c(\"pat\", \"arrivetime\", \"eventtime\", \"tottime\", \"dropouttime\", paste(\"time cutoff = \", cutoff, sep = \"\"), paste(\"event cutoff = \", cutoff, sep = \"\"))\n  \n  res <- list(\"cutoff.time\" = cutoff.time, \"tab\" = tab)\n  return(res)\n}\n\n# censored time-to-event data with censoring after pre-specified number of events, for two treatment arms\nrWeibull2arm <- function(shape = c(1, 1), scale, cure = c(0, 0), recruit, dropout = c(0, 0), start.accrual = c(0, 0), cutoff, seed = NA){\n  \n  # shape             2-d vector of Weibull shape parameter. \n  # scale             2-d vector of Weibull scale parameter.\n  # cure:             2-d vector with cure proportion assumed in each arm.\n  # recruit:          List with two elements, vector of recruitment in each arm.\n  # dropout:          2-d vector with drop-out rate for each arm, on same time scale as med.\n  # start.accrual:    2-d vector of time when accrual should start. Might be useful when simulating multi-stage trials.\n  # cutoff:           Cutoff, #events the final censored data should have (can be a vector of multiple cutoffs).\n  # seed:             If different from NA, seed used to generate random numbers.\n  #\n  # Kaspar Rufibach, June 2014\n  \n  if (is.na(seed) == FALSE){set.seed(seed)}\n  \n  dat1 <- rWeibull1arm(scale = scale[1], shape = shape[1], recruit = recruit[[1]], cutoff = 1, \n                                      dropout = dropout[1], cure = cure[1], start.accrual = start.accrual[1], seed = NA)$tab\n  dat2 <- rWeibull1arm(scale = scale[2], shape = shape[2], recruit = recruit[[2]], cutoff = 1, \n                                      dropout = dropout[2], cure = cure[2], start.accrual = start.accrual[2], seed = NA)$tab\n  \n  n <- c(nrow(dat1), nrow(dat2))\n  \n  # treatment variable\n  tmt <- factor(c(rep(0, n[1]), rep(1, n[2])), levels = 0:1, labels = c(\"A\", \"B\"))\n  \n  arrivetime <- c(dat1[, \"arrivetime\"], dat2[, \"arrivetime\"])\n  eventtime <- c(dat1[, \"eventtime\"], dat2[, \"eventtime\"])\n  tottime <- c(dat1[, \"tottime\"], dat2[, \"tottime\"])\n  dropouttime <- c(dat1[, \"dropouttime\"], dat2[, \"dropouttime\"])\n  \n  # Apply drop-out. Do this before applying the cutoff below, in order to correctly count necessary #events.\n  event.dropout <- ifelse(eventtime > dropouttime, 0, 1)\n  time.dropout <- ifelse(event.dropout == 1, eventtime, dropouttime)   \n  \n  # find cutoff based on number of targeted events\n  # only look among patients that are not considered dropped-out\n  time <- data.frame(matrix(NA, ncol = length(cutoff), nrow = sum(n)))\n  event <- time\n  cutoff.time <- rep(NA, length(cutoff))\n  \n  for (j in 1:length(cutoff)){\n    cutoff.time[j] <- sort(tottime[event.dropout == 1])[cutoff[j]]\n    \n    # apply administrative censoring at cutoff\n    event[event.dropout == 1, j] <- ifelse(tottime[event.dropout == 1] > cutoff.time[j], 0, 1)\n    event[event.dropout == 0, j] <- 0\n    \n    # define time to event, taking into account both types of censoring\n    time[event.dropout == 1, j] <- ifelse(event[, j] == 1, eventtime, cutoff.time[j] - arrivetime)[event.dropout == 1]    \n    time[event.dropout == 0, j] <- pmin(cutoff.time[j] - arrivetime, time.dropout)[event.dropout == 0]\n    \n    # remove times for patients arriving after the cutoff\n    rem <- (arrivetime > cutoff.time[j])\n    if (TRUE %in% rem){time[rem, j] <- NA}\n  }\n  \n  # generate output\n  tab <- data.frame(cbind(1:sum(n), tmt, arrivetime, eventtime, tottime, dropouttime, time, event))\n  colnames(tab) <- c(\"pat\", \"tmt\", \"arrivetime\", \"eventtime\", \"tottime\", \"dropouttime\", \n                     paste(\"time cutoff = \", cutoff, sep = \"\"), paste(\"event cutoff = \", cutoff, sep = \"\"))\n\n  res <- list(\"cutoff.time\" = cutoff.time, \"tab\" = tab)\n  return(res)\n}\n\n# functions to plot results\nhoriz <- function(vert = FALSE){\n  segments(0, 1, 1, 1, col = 5, lwd = 4, lty = 1)\n  segments(0, hr, 1, hr, col = 4, lwd = 4, lty = 1)\n  segments(0, mdd_no_interim, 1, mdd_no_interim, col = 2, lwd = 4, lty = 1)\n  \n  legend(\"topright\", paste(\"HR = \", disp(c(1, mdd_no_interim, hr), 2), \" (\", \n                           c(\"futility boundary\", \"minimal detectable difference\", \"effect we power at\"), \")\", \n                           sep = \"\"), bty = \"n\", lty = 1, col = c(5, 2, 4), lwd = 4)\n  \n  # vertical line\n  if (vert){segments(inter_x[1], 0, inter_x[1], 1.42, lty = 2, col = 6)}\n}\n\nplot_empty <- function(){\n  inter_x <- cutoff / max(cutoff)\n  yli_traj <- c(0.4, 1.5)\n  \n  par(las = 1)\n  par(mar = c(3, 4, 1, 4), las = 1)\n  plot(0, 0, type = \"n\", xlim = c(0, 1), ylim = yli_traj, xlab = \"\", xaxt = \"n\", ylab = \"hazard ratio\")\n  axis(side = 4, at = seq(0, 2, by = 0.2), labels = disp(seq(0, 2, by = 0.2), 1))\n  axis(side = 1, at = inter_x[2], labels = c(\"interim\", \"final\")[2])\n}\n```\n:::\n\n\n# Trial design\n\nFirst, let us specify the basic parameters of a Phase 3 clinical trial with a time-to-event endpoint:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  trial operating characteristics\nalpha <- 0.05\nbeta <- 0.2\n\n# exponential survival functions \nm1 <- 6 * 12\nm2 <- 8 * 12\nmed <- c(m1, m2)\n\n# effect to have 80% power at\nhr <- m1 / m2\n\n# accrual\nrecruit1 <- rep(25, 16)\nrecruit2 <- recruit1\nrecruit <- list(recruit1, recruit2)\nn <- sum(unlist(recruit))\nstart.accrual <- c(0, 0)\n\n# drop-out (2.5% annually)\ndropout.year <- 0.025\ndropout.month <- -log(1 - dropout.year) / 12\ndropout <- rep(dropout.month, 2)\n\n# cure proportion \ncure <- c(0, 0)\n\n# We assume the shape parameter of the Weibull distribution is = 1.\n# Compute the scale parameter corresponding to the above median for Exponential:\nlambda <- log(2) / med\nscale <- 1 / lambda\n\n# specification of interim analysis\ninfo_interim <- 0.3\nfutilityHR <- 1\n```\n:::\n\n\nSo we plan a trial assuming:\n\n- 1:1 randomization,\n- a futility interim analysis after 30% of events,\n- 80% power to \n- detect a hazard ratio (HR) of 0.75 \n- using a two-sided logrank test \n- with a significance level of 0.05.\n\n# Simulation of trials with and without futility interim analysis\n\nWe will simulate such trials to illustrate the false-positive risk of a futility interim. For the simulation we need to specify a few more quantities:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Required events without interim\nnevent <- getSampleSizeSurvival(lambda1 = getLambdaByMedian(m2), lambda2 = getLambdaByMedian(m1), \n                                sided = 1, alpha = alpha / 2, beta = beta)\nmdd_no_interim <- nevent$criticalValuesEffectScale[1, 1]\nnevent <- ceiling(nevent$maxNumberOfEvents)\n\n# cutoffs\neventsInterim <- ceiling(info_interim * nevent)\ncutoff <- c(eventsInterim, nevent)\n\n# number of simulations\nM <- 10 ^ 3\n\n# now simulate trials and record hazard ratios at interim and final analysis cutoff\nresHR <- data.frame(matrix(NA, nrow = M, ncol = length(cutoff)))\ncolnames(resHR) <- cutoff\nresp <- resHR\n\nfor (i in 1:M){\n  res2arm <- rWeibull2arm(scale = scale, shape = c(1, 1), \n                        cure = cure, recruit, dropout, start.accrual, cutoff, seed = NA)$tab\n\n  for (j in 1:length(cutoff)){\n    \n    # compute hazard ratio for this cutoff\n    tmt <- res2arm[, \"tmt\"]\n    time <- res2arm[, paste(\"time cutoff = \", cutoff[j], sep = \"\")]\n    event <- res2arm[, paste(\"event cutoff = \", cutoff[j], sep = \"\")]\n\n    cox1 <- summary(coxph(Surv(time, event) ~ tmt))\n    resHR[i, j] <- exp(coef(cox1)[1])\n    resp[i, j] <- coef(cox1)[1, \"Pr(>|z|)\"]\n  }\n}\n```\n:::\n\n\n# Quantification of power loss of interim analysis, and graphical illustration\n\nWe have now 1000 simulated trials with a hazard ratio estimate at the interim and final analysis. First, let us plot results assuming there would be no interim analysis. The horizontal lines correspond to the futility boundary, the minimal detectable difference (i.e. the hazard ratio we need to observe at the final analysis to be statistically significant), and the hazard ratio for which we specified the sample size to have 80% power at. They grey lines illustrate the hazard ratios we observe at the final analysis using these assumptions, with green lines those trials that would be statistically significant, i.e. land below the red horizontal line. These are 79.9% of trials (an estimate of the power).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_empty()\n\n# plot trajectories to final only\nsegments(0, hr, 1, resHR[, 2], col = grey(0.9), lty = 1)\n\n# significant trajectories\nsegments(0, hr, 1, resHR[resHR[, 2] <= mdd_no_interim, 2], col = 3, lty = 1)\n\nhoriz()\n```\n\n![](20240306_futility_fp_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=672}\n:::\n\n\nNow, we know that by adding a futility interim we reduce trial power, because we erroneously stop some trials that would be statistically significant at the final analysis. But how many? In order to find out we have to filter out those trials for which\n\n- the hazard ratio at the interim analysis is above 1 (i.e. the interim boundary for futility) but\n- below 0.818, i.e. the minimal detectable difference at the final analysis.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot_empty()\ninter_x <- cutoff / max(cutoff)\naxis(side = 1, at = inter_x[1], labels = c(\"interim\", \"final\")[1])\n\n# all trajectories including interim\nsegments(0, hr, inter_x[1], resHR[, 1], col = grey(0.9), lty = 1)\nsegments(inter_x[1], resHR[, 1], 1, resHR[, 2], col = grey(0.9), lty = 1)\n\n# color the false negatives: stopped at interim but sig at final\nind <- (resHR[, 1] > 1 & resHR[, 2] <= mdd_no_interim)\nsegments(0, hr, inter_x[1], resHR[ind, 1], col = 3, lty = 1)\nsegments(inter_x[1], resHR[ind, 1], 1, resHR[ind, 2], col = 3, lty = 1)\n\nhoriz(vert = TRUE)\n```\n\n![](20240306_futility_fp_files/figure-html/unnamed-chunk-6-1.png){fig-align='center' width=672}\n:::\n\n\n\nThe plot above indicates those 2.2% of trials that would be erronously stopped at the futility interim analysis. This is what is typically called the <font color='red'>power loss</font> of the futility interim analysis. ",
    "supporting": [
      "20240306_futility_fp_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}